<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="��������">
<meta property="og:type" content="website">
<meta property="og:title" content="It&#39;s my blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="It&#39;s my blog">
<meta property="og:description" content="��������">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="It&#39;s my blog">
<meta name="twitter:description" content="��������">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>It's my blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">It's my blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Java</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/原-Java多线程之CountDwonLatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/原-Java多线程之CountDwonLatch/" itemprop="url">[原]Java多线程之CountDwonLatch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T21:07:19+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>CountDwonLatch是一个非常实用的多线程控制工具类，这个工具类通常用来控制线程等待，它可以让某个线程等待直到其它线程执行任务结束，在开始执行。下面先看代码，根据代码分析程序，提出问题。
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Executors;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CountDownLatchDemo&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; CountDownLatch lock = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; CountDownLatchDemo task = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CountDownLatchDemo();

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;hljs-comment&quot;&gt;//模拟任务&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
            Thread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);
            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;线程&quot;&lt;/span&gt; + Thread.currentThread().getName());
            lock.countDown();
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;  i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; ++i) {
            service.submit(task);
        }
        lock.await();
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;主线程执行了&quot;&lt;/span&gt;);
        service.shutdown();
    }
}`&lt;/pre&gt;

&lt;pre&gt;`代码第六行生成一个CountDwonLatch实例。计数量为100（有点类似与一组信号量）。在这段代码中这表示需要100个线程完成任务，等待在CountDwonLatch上的线程才能继续往下执行。最后的执行结果即主线程等待线程池中提交任务执行结束后，才会接着继续执行。那么就有一个疑问：当前情况是在拥有5个线程的线程池中提交了100个任务。即100个任务执行完成后，100个计数被消耗后，主线程才开始执行。这样看的话，CountDwonLatch中的计数数量就仅仅作为一个辅助的县城管理工具，每个线程执行一次，自身减一，只到计数量为0。如果是这样，那么使用单线程循环执行100次，同样可以达到相同的结果，下面编程验证：
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Executors;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CountDownLatchDemo2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; CountDownLatchDemo2 task = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CountDownLatchDemo2();
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; CountDownLatch lock = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (i++ &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;) {
                Thread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;线程:&quot;&lt;/span&gt; + Thread.currentThread().getName());
                lock.countDown();
            }
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;  i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; ++i) {
            service.submit(task);
        }

        lock.await();
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;主线程执行了&quot;&lt;/span&gt;);
        service.shutdown();
    }
}`&lt;/pre&gt;

&lt;pre&gt;`测试情况为在单线程的线程池中，提交了单次任务，在线程任务中，循环100次。经过测试发现，主线程同样是在线程池中线程任务执行完后，继续执行。

经过上面的测试，我们看以看出CountDwonLatch本身是一个不与线程耦合的计数器，每执行一次countDown()方法，计数器数量减一。直到减为0为止，等待在CountDwonLatch才会有执行机会。这样我们可以大胆的猜测，如果CountDwonLatch本身的计数器一旦被消耗完（即为0时），等待其上面的线程即获得了执行权，不在被阻塞。（经测试，确实是这样）。它本身只充当一个线程辅助工具类。

        &lt;div&gt;
            作者：StruggleShu 发表于2017/6/15 21:07:19 [原文链接](http://blog.csdn.net/struggleshu/article/details/73302580)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：239 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/73302580#comments)
        &lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/14/原-枚举单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/14/原-枚举单例模式/" itemprop="url">[原]枚举单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-14T21:12:24+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>Java中的枚举类非常强大的。之前看过单例的许多实现，对于枚举的单例略有了解，但理解不够深刻，最近结合实例研究了一下，感觉枚举是很强大且非常好用。

首先看一个最简单的枚举单例模式:
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt;  TestEnum {
    TEST_ENUM;
}`&lt;/pre&gt;

&lt;pre&gt;`其中TEST_ENUM，即为TestEnum类的唯一实例。这样写可能一眼看去，没什么意义。也不是很好理解。下面以生成一个单例的CGLib动态代理类作为场景进行总结。先放代码：
`&lt;/pre&gt;

## 代理类

&lt;pre class=&quot;prettyprint&quot;&gt;`import java.lang.reflect.&lt;span class=&quot;hljs-keyword&quot;&gt;Method&lt;/span&gt;;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; CGLibProxyEnum &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; MethodInterceptor &lt;span class=&quot;hljs-comment&quot;&gt;{
    CG_LIB_PROXY_ENUM;

    public &amp;lt;T&amp;gt; T getProxy(Class&amp;lt;T&amp;gt; cls) {
        return (T)Enhancer.create(cls, this);
    }&lt;/span&gt;

    @&lt;span class=&quot;hljs-keyword&quot;&gt;Override&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Object intercept(Object o, &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Object&lt;/span&gt;[] &lt;span class=&quot;hljs-title&quot;&gt;objects&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;MethodProxy&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;methodProxy&lt;/span&gt;) &lt;span class=&quot;hljs-title&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;{
        return methodProxy.invokeSuper(o, objects);
    }&lt;/span&gt;
}&lt;/span&gt;`&lt;/pre&gt;

## 测试类

&lt;pre class=&quot;prettyprint&quot;&gt;`class Hello {
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sayHello&lt;/span&gt;() {
        System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello, new Boys&quot;&lt;/span&gt;);
    }
}
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; Test {
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) {
        Hello helloProxy = CGLibProxyEnum.CG_LIB_PROXY_ENUM.getProxy(Hello.class);
        helloProxy.sayHello();
   }
}
`&lt;/pre&gt;

&lt;pre&gt;`测试结果打印：Hello, new Boys

上面的CGLibProxyEnum枚举类实现了MethodInterceptor接口，并重写了其中的intercept方法。在其内部创建了唯一的实例CG_LIB_PROXY_ENUM；这是由其默认的私有的构造器创建的。
这里可以看出，枚举单例模式非常简单，易于实现，且类型安全。而且有着和普通类一样的基本功能。并且枚举类默认final修饰，不允许被继承。

        &lt;div&gt;
            作者：StruggleShu 发表于2017/6/14 21:12:24 [原文链接](http://blog.csdn.net/struggleshu/article/details/73252230)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：219 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/73252230#comments)
        &lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/13/原-Java中的枚举/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/13/原-Java中的枚举/" itemprop="url">[原]Java中的枚举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-13T18:08:21+08:00">
                2017-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>虽然知道在Java中存在枚举类型，但是却一直很少用。最近接触了一些，特加以总结。
`&lt;/pre&gt;

# 枚举类型的定义

&lt;pre&gt;`枚举类型是指由一组固定的常量组成合法值的类型。比如我们常用的：
    public static final static ERROR = -1;
    public static final static SUCCESS = 1;
根据枚举类型的定义，其实这也属于一种枚举，一种int枚举模式。这种模式存在类型安全性问题。如果你错把ERROR传入想要SUCCESS的方法中去，编译器也不会报错。
`&lt;/pre&gt;

# Java中的枚举

下面是一个简单的JAVA枚举类。

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; PostLogisticsInfoEnum {
    SUCCESS(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;发布成功&quot;&lt;/span&gt;),
    ERROR(-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;发布失败&quot;&lt;/span&gt;),
    TEST(&lt;span class=&quot;hljs-string&quot;&gt;&quot;测试&quot;&lt;/span&gt;);

    &lt;span class=&quot;hljs-comment&quot;&gt;//状态&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Integer state;
    &lt;span class=&quot;hljs-comment&quot;&gt;//信息&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String info;

    PostLogisticsInfoEnum(Integer state, String info) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;(info);
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.state = state;
    }

    PostLogisticsInfoEnum(String info) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.info = info;
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;getState&lt;/span&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; state;
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getInfo&lt;/span&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; info;
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; PostLogisticsInfoEnum &lt;span class=&quot;hljs-title&quot;&gt;stateOf&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (PostLogisticsInfoEnum infoEnum : values()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (infoEnum.getState() == index) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; infoEnum;
            }
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
    }
}`&lt;/pre&gt;

# java枚举类特点

&lt;pre&gt;` 1、构造器默认使用private修饰符修饰（其它修饰符不被允许），这样可以看出枚举类都是单例的，即不允许外部类构造枚举对象。但是可以在枚举类内部定义多个枚举实例。
 2、枚举类构造器和一般类一样，同样允许构造器的重载
 3、 每个枚举类内部存在一个静态的values()方法，它返回一个包含全部枚举值的数组
`&lt;/pre&gt;

# java中枚举的优点：

&lt;pre&gt;`1、Java枚举通过公有的静态final域为每个枚举常量导出实例的类。因为没有可以访问的构造器，枚举类型是真正的final。
2、枚举提供了编译时的类型安全。
3、允许添加任意的方法和域，并实现任意的接口。提供了所有Object方法的高级实现实现了Comparable和Serializable接口，并针对枚举类型的可任意改变性设计了序列化方式。

        &lt;div&gt;
            作者：StruggleShu 发表于2017/6/13 18:08:21 [原文链接](http://blog.csdn.net/struggleshu/article/details/73176217)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：107 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/73176217#comments)
        &lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/原-HTTP缓存字段总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/原-HTTP缓存字段总结/" itemprop="url">[原]HTTP缓存字段总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-12T16:01:36+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>    HTTP控制缓存的字段主要包括Cache-Control/Pragma,Expires,Last-Modified/Etag。
`&lt;/pre&gt;

## 1、Cache-Control/Pragma

&lt;pre&gt;`    这个HTTP Head字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP相关的缓存或代理服务器。它可以指定下列可选值：
    1、Public：所有内容都将被缓存，在响应头中设置
    2、Private：内容只缓存在私有缓存中，在响应头中设置
    3、no-cache：所有内容都不会被缓存，在请求头和响应头中设置
    4、no-store：所有内容都不会被缓存在缓存或Internet临时文件中，在响应头中设置
    5、must-revalidation/proxy-revalidation：如果缓存的内容失效，请求必须发送到服务  器/代理以进行重新验证，在请求头中设置
    6、max-age=xxx：缓存的内容将在xxx秒后失效，这个选项只在HTTP1.1中可用，和Last-Modified一起使用时优先级较高，在响应头中设置

    Cache-Control请求字段可以被个浏览器很好的支持，而且优先级也比较高，它和其他一些请求字段（如Expires）同时使用时，Cache-Control会覆盖其他字段

    Pragma字段的作用和Cache-Control类似，最常用的Pragma:no-cache，他和Cache-cache的作用是一致的。
`&lt;/pre&gt;

## 2、Expires

&lt;pre&gt;`    Expires通常的使用格式是Expires:Sat,25 Feb 2012 12:22:17 GMT,后面跟着一个日期和时间，超过这个时间后，缓存的内容将失效，浏览器在发送请求之前检查这个页面的字段，看该页面是否已经过期了，如果过期，就向服务端重新发起请求。
`&lt;/pre&gt;

## 3、Last-Modified/Etag

&lt;pre&gt;`    Last-Modified字段一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态资源，也可以是动态内容，通过这个最后修改时间可以判断当前请求的资源是否是最新的。
    一般服务端会在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如Last-Modified:Sat, 25 Feb 2012 12:55:04 GMT,浏览器再次请求时在请求头中增加If-Modified-Since:Sat, 25 Feb 2012 12:55:04 GMT字段，询问当前缓存的页面是否是最新。如果是最新的就返回304，告诉浏览器是最新的，服务器也不会传输最新的数据
    Etag字段的作用和LastModified字段作用相同，这个字段的作用是让服务端给每个页面分配一个唯一的编号，然后通过这个编号来区分当前页面是否最新。这种方式比较灵活，但是当后端的服务器有多台时比较难以处理。
下图为一个实例
`&lt;/pre&gt;

![HTTP缓存字段](http://img.blog.csdn.net/20170612160230252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

&lt;pre&gt;`可以明显的看到上面介绍的几个字段。
    1、Cache-Control:max-age=2592000：缓存内容将在2592000秒后失效（30天）。
    2、ETag:&quot;58d48c15-f7b&quot;：页面编号
    3、Expires:Wed, 12 Jul 2017 05:42:41 GMT：缓存内容将在2017年7月12日后过时。
    4、Last-Modified:Fri, 24 Mar 2017 03:01:41 GMT：服务端资源最后修改时间。
</code></pre><p><em><em>          但是由于Cache-Control字段的存在，会覆盖其他字段。</em></em></p>
<pre><code>&lt;div&gt;
    作者：StruggleShu 发表于2017/6/12 16:01:36 [原文链接](http://blog.csdn.net/struggleshu/article/details/73113459)
&lt;/div&gt;
&lt;div&gt;
阅读：181 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/73113459#comments)
&lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/11/原-Wireshark抓包分析TCP的三次握手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/11/原-Wireshark抓包分析TCP的三次握手/" itemprop="url">[原]Wireshark抓包分析TCP的三次握手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-11T13:54:54+08:00">
                2017-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>   今天学习了Wireshark工具，对于抓包有了极大的兴趣；特意通过抓包来加深一下TCP三次握手的过程，同时做以记录。
`&lt;/pre&gt;

### TCP报文段结构

![这里写图片描述](http://img.blog.csdn.net/20170611133448163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 过滤规则介绍

&lt;pre&gt;`   网络中包含着许多的数据报文，但是许多的都不是我们需要的。网上给的大多数规则不够具体，通过查阅资料，用下面的过滤规则可以更快的抓取TCP三次握手的包.
`&lt;/pre&gt;

**tcp.flags.syn == 0x02 || tcp.flags.ack == 0x02 &amp;amp;&amp;amp; tcp.flags.fin != 0x02** 

![这里写图片描述](http://img.blog.csdn.net/20170611133518264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### TCP的三次握手文字表述

####第一步：客户端的TCP首先向服务端的TCP发送一个特殊的TCP报文段。报文段中不包含应用层数据。但是在报文段的首部中的标志位SYN被值为1。这个特殊的报文段通常被称为SYN报文段。同时客户会随机选择一个初始序号(client_isn)，并将该序号置于SYN报文段的序号字段中。 

 ####第二步：包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户端TCP发送允许连接的报文段。首先，SYN字段被置1.其次该TCP报文段首部的确认号字段被置为client_isn+1;最后，服务器选择自己的初始序号(server_isn)，并放入到该TCP的首部的序号字段中，该允许连接的报文段通常被称为SYNACK报文段。 

 ####第三步：在接收到SYNACK报文段后，客户端也要给该TCP连接分配缓存和变量。客户主机想服务端发送另一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认。客户端将值server_isn+1放入到TCP首部的确认号字段。因为连接已经建立了，所以SYN比特被置为0。

### TCP三次握手抓包结果

![TCP三次握手抓包结果](http://img.blog.csdn.net/20170611133601077?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 

![三次握手流图](http://img.blog.csdn.net/20170611133615586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 三次握手每个包中的具体数据

#### 第一次握手数据报，可以看出SYN被置1

![第一次握手](http://img.blog.csdn.net/20170611134004707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 第二次握手数据报，可以看出SYN被置1，ACK被置1，确认号字段被置1

![第二次握手](http://img.blog.csdn.net/20170611134019364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 第三次握手数据报，SYN置0，ACK置1.序号和确认号被置1

![第三次握手](http://img.blog.csdn.net/20170611134035697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3RydWdnbGVTaHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

&lt;pre&gt;`   通过Wireshark工具抓包，对TCP的三次握手过程有了直观化的理解。

        &lt;div&gt;
            作者：StruggleShu 发表于2017/6/11 13:54:54 [原文链接](http://blog.csdn.net/struggleshu/article/details/73026822)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：250 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/73026822#comments)
        &lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/11/原-JSON字符串，JSON对象，JSON数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/11/原-JSON字符串，JSON对象，JSON数组/" itemprop="url">[原]JSON字符串，JSON对象，JSON数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-11T11:23:53+08:00">
                2017-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>JSON的全称是&quot;JavaScript Object Notation&quot;，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。

JSON必须是符合以下两点：
   1.键一定要用双引号，值如果是字符串也要用双引号包括
   2.数据只包括，数字，布尔，数组，null，对象，字符串
下面先给出JSON对象，JSON字符串，JSON数组的基本形式，用于对比   
JSON对象
{ &quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot; }
JSON字符串
&apos;{&quot;name&quot;:&quot;2323&quot;,&quot;sex&quot;:&quot;afasdf&quot;,&quot;age&quot;:&quot;6262&quot;}&apos;
JSON数组
[
    {
        &quot;name&quot;:&quot;tom&quot;,
        &quot;sex&quot;:&quot;男&quot;,
        &quot;age&quot;:&quot;24&quot;
    },
    {
        &quot;name&quot;:&quot;LiMing&quot;,
        &quot;sex&quot;:&quot;男&quot;,
        &quot;age&quot;:&quot;20&quot;
    }
]
可以很明显的发现区别：
   1、JSON对象以大括号中包含以逗号分割的键值对；
   2、JSON字符串则是在JSON对象的基础上在大括号外面加上双引号。
   3、JSON数组则是方括号中包含多个以逗号分割的JSON对象。
具体的细节请点击下面链接
[http://www.json.org/json-zh.html]

        &lt;div&gt;
            作者：StruggleShu 发表于2017/6/11 11:23:53 [原文链接](http://blog.csdn.net/struggleshu/article/details/73017670)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：122 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/73017670#comments)
        &lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/04/原-Ubuntu15-10-下安装Oracle-11g/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/04/原-Ubuntu15-10-下安装Oracle-11g/" itemprop="url">[原]Ubuntu15.10 下安装Oracle 11g</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-04T21:07:38+08:00">
                2016-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学Oracle数据库之前，首先面临的是安装数据库Oracle数据库，前几天在ubuntu下安装好了，现在总结一下安装过程.</p>
<p>系统信息：ubuntu15.10桌面版，linux内核版本4.2.0-36-generic((终端输入uname -r 可查看内核版本) (ps:此信息仅供参考)</p>
<pre><code>&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.前提工作`&lt;/pre&gt;

&lt;pre&gt;`1.1下载Oracle 11g R2 Express Edition和Oracle SQL Developer
Oralce 11g: http://www.oracle.com/technetwork/database/database-technologies/express-edition/downloads/index.html
1.2检查交换分区
我的机子之前交换分区是2G，结果安装时显示交换分区大小不足，然后就又增加了2G(之后安装时问题解决)
1.2.1增加交换分区的方法(若不存在此问题，请跳过)
    1.查看当前swap分区的状态
    cat /proc/meminfo (或者执行 free -m可查看当前交换分区的大小)
    SwapTotal: 0KB
    SwapFree: 0KB
    如果上边两项都为0，说明没有swap分区；否则，说明有此分区
    2.如果没有swap分区，则先创建。在&quot;/&quot;目录下执行如下指令
    A. sudo dd if=/dev/zero of=swap.disk bs=1M count=4k (如果要创建4G则count=4k；这步比较慢)
    B. sudo mkswap -f swap.disk
    C. sudo swapon swap.disk
    3.如果有，但交换分区不足(不满足装Oracle 11g所需空间)的，则可以在用户目录下(/home/user)下执行如下命令
    A.mkdir swap
    B.cd swap
    C.sudo dd if=/dev/zero of=swapfile bs=1024 count=100000
    上面命令中的count即代表要增加的swap文件的大小，执行后会出现如下提示：
    记录了 100000+0 的读入
    记录了 100000+0 的写出
    102400000 字节 (102MB) 已复制， 0.64223 秒， 142MB/秒
    D.把生成的文件转换成Swap文件
    sudo mkswap swapfile  
    Setting up swapspace version 1, size = 102395 kB  
    no label, UUID=09fde987-5567-498a-a60b-477e302a988b  
    E.激活swap分区
    sudo swapon swapfile
    F.再次(free -m)查看交换分区大小
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`2.解压并安装需要的软件`&lt;/pre&gt;

&lt;pre&gt;`A.解压：unzip oracle-xe-11.2.0-1.0.x86_64.rpm.zip
B.将.rmp文件转换为.deb文件: sudo alien --scripts -d oracle-xe-11.2.0-1.0.x86_64.rpm (过程比较慢，等待一会)
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`3.创建所需文件并设置权限`&lt;/pre&gt;

&lt;pre&gt;`A.创建文件：sudo vim /sbin/chkconfig
文件内容
1.#!/bin/bash
2.# Oracle 11gR2 XE installer chkconfig hack for Ubuntu
3.file=/etc/init.d/oracle-xe
4.if [[ ! `tail -n1 $file | grep INIT` ]]; then
5.echo &amp;gt;&amp;gt; $file
6.echo &apos;### BEGIN INIT INFO&apos; &amp;gt;&amp;gt; $file
7.echo &apos;# Provides: OracleXE&apos; &amp;gt;&amp;gt; $file
8.echo &apos;# Required-Start: $remote_fs $syslog&apos; &amp;gt;&amp;gt; $file
9.echo &apos;# Required-Stop: $remote_fs $syslog&apos; &amp;gt;&amp;gt; $file
10.echo &apos;# Default-Start: 2 3 4 5&apos; &amp;gt;&amp;gt; $file
11.echo &apos;# Default-Stop: 0 1 6&apos; &amp;gt;&amp;gt; $file
12.echo &apos;# Short-Description: Oracle 11g Express Edition&apos; &amp;gt;&amp;gt; $file
13.echo &apos;### END INIT INFO&apos; &amp;gt;&amp;gt; $file
14.fi
15.update-rc.d oracle-xe defaults 80 01
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`B.设置权限：chmod &lt;span class=&quot;hljs-number&quot;&gt;755&lt;/span&gt; /sbin/chkconfig
C.创建文件：sudo vim /etc/sysctl&lt;span class=&quot;hljs-preprocessor&quot;&gt;.d&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;-oracle&lt;span class=&quot;hljs-preprocessor&quot;&gt;.conf&lt;/span&gt; 
    文件内容：
    &lt;span class=&quot;hljs-preprocessor&quot;&gt;#racle 11g XE kernel parameters  &lt;/span&gt;
    fs&lt;span class=&quot;hljs-preprocessor&quot;&gt;.file&lt;/span&gt;-max=&lt;span class=&quot;hljs-number&quot;&gt;6815744&lt;/span&gt;  
    net&lt;span class=&quot;hljs-preprocessor&quot;&gt;.ipv&lt;/span&gt;4&lt;span class=&quot;hljs-preprocessor&quot;&gt;.ip&lt;/span&gt;_local_port_range=&lt;span class=&quot;hljs-number&quot;&gt;9000&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;65000&lt;/span&gt;  
    kernel&lt;span class=&quot;hljs-preprocessor&quot;&gt;.sem&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;32000&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt; 
    kernel&lt;span class=&quot;hljs-preprocessor&quot;&gt;.shmmax&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;536870912&lt;/span&gt;

D.接着执行以下命令`&lt;/pre&gt;

&lt;pre&gt;`sudo cat /etc/sysctl.d/60-oracle.conf

sudo service procps start

sudo sysctl -q fs.file-max
将会输出：-&amp;gt; fs.file-max = 6815744 （数值不一定相等）
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`4.创建文件链接（如果是再次重装，这里可能显示已存在，那就接着往下）`&lt;/pre&gt;

&lt;pre&gt;`ln -s /usr/bin/awk /bin/awk

mkdir /var/lock/subsys

touch /var/lock/subsys/listener
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`5.安装Oracle`&lt;/pre&gt;

&lt;pre&gt;`sudo dpkg --install oracle-xe_11.2.0-2_amd64.deb
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`6.创建配置`&lt;/pre&gt;

&lt;pre&gt;`sudo /etc/init.d/oracle-xe configure
之后，会引导用户进行简单的几项设置：
Oracle Database 11g Express Edition Configuration
-————————————————
This will configure on-boot properties of Oracle Database 11g Express
Edition. The following questions will determine whether the database should
be starting upon system boot, the ports it will use, and the passwords that
will be used for database accounts. Press to accept the defaults.
Ctrl-C will abort.
Specify the HTTP port that will be used for Oracle Application Express [8080]:8081
Specify a port that will be used for the database listener [1521]:1521
Specify a password to be used for database accounts. Note that the same
password will be used for SYS and SYSTEM. Oracle recommends the use of
different passwords for each database account. This can be done after
initial configuration:
Confirm the password:
Do you want Oracle Database 11g Express Edition to be started on boot (y/n) [y]:y
Starting Oracle Net Listener…Done
Configuring database…Done
Starting Oracle Database 11g Express Edition instance…Done
Installation completed successfully.
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`输入的四项内容是：`&lt;/pre&gt;

&lt;pre&gt;`http访问时的端口
数据库的监听端口
SYS和SYSTEM用户的密码
是否开机启动（并没有开机启动，可能还有地方要设置）。
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`安装完成后：`&lt;/pre&gt;

&lt;pre&gt;`会自动建立一个名为oracle的用户，家目录/u01/app/oracle。
会建立dba组，oracle用户属于这个组。
会自动生成一个数据库实例，名为XE。/u01/app/oracle/product/11.2.0/xe/dbs/spfileXE.ora
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`7.配置环境变量`&lt;/pre&gt;

&lt;pre&gt;`vi /etc/profile   
加入

export ORACLE_HOME=/u01/app/oracle/product/11.2.0/xe
export ORACLE_SID=XE
export NLS_LANG=`$ORACLE_HOME/bin/nls_lang.sh`
export ORACLE_BASE=/u01/app/oracle
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATH
export PATH=$ORACLE_HOME/bin:$PATH

接着执行：
source /etc/profile
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`8.启动Orcale`&lt;/pre&gt;

&lt;pre&gt;`sudo service oracle-xe start

Oracle Database 11g Express Edition instance is already started.
`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`9.登录Orcale`&lt;/pre&gt;

&lt;pre&gt;`sqlplus sys as sysdba

        &lt;div&gt;
            作者：StruggleShu 发表于2016/6/4 21:07:38 [原文链接](http://blog.csdn.net/struggleshu/article/details/51586103)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：1274 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/51586103#comments)
        &lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/09/原-二分查找的非递归和递归例程实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/09/原-二分查找的非递归和递归例程实现/" itemprop="url">[原]二分查找的非递归和递归例程实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-09T22:06:15+08:00">
                2016-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="font-size:18px">二分查找：定义一个整数X，和整数A(0)，A(1)，A(2)，……A(N-1),后者已经预先排序并在内存中，求使得Ai=X的下标<em>i,如果X不存在，则返回-1。</em></span></p>
<p><span style="font-size:18px"><em>策略：验证X是否是居中的,如果是，则答案找到。如果X小于居中元素，应用同样的策略于居中元素左边已排序的子序列;同理，如果大于居中元素，那么就检查数据的右半部分。</em></span></p>
<p></p>
<p><span style="font-size:18px">二分查找的非递归实现(复杂度O(logN))</span></p>
<p><span style="font-size:18px">int BinarySearch(<span style="font-size:18px">ElementType</span> a[],<br><span style="font-size:18px">ElementType</span> x, int N)</span></p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; int Low, Mid, High;</p>
<p>&nbsp;&nbsp;&nbsp; Low = 0;</p>
<p>&nbsp;&nbsp;&nbsp; High = N - 1;</p>
<p>&nbsp;&nbsp;&nbsp; while(Low &lt;= High)</p>
<p>&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mid = (Low &#43; High) / 2;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[Mid] &lt; x)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Low = Mid &#43; 1;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (a[Mid] &gt; x)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; High = Mid -1;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Mid;</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; return notFound;</p>
<p>}</p>
<p></p>
<p><span style="font-size:18px">二分查找的递归实现<span style="font-size:18px">(复杂度O(logN))</span></span></p>
<p><span style="font-size:18px">int BinarySearch(const ElementType a[], <span style="font-size:18px"><br>ElementType</span> data, int Low, int High)</span></p>
<p>{</p>
<p>&nbsp;&nbsp; &nbsp;int mid = (Low &#43; High) / 2;</p>
<p>&nbsp;&nbsp; &nbsp;if (data == a[mid])</p>
<p>&nbsp;&nbsp; &nbsp;{</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return mid;</p>
<p>&nbsp;&nbsp; &nbsp;}</p>
<p>&nbsp;&nbsp; &nbsp;else if (data &lt; a[mid])</p>
<p>&nbsp;&nbsp; &nbsp;{</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return BinarySearch(a, data, Low, mid - 1);</p>
<p>&nbsp;&nbsp; &nbsp;}</p>
<p>&nbsp;&nbsp; &nbsp;else if (data &gt; a[mid])</p>
<p>&nbsp;&nbsp; &nbsp;{</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return BinarySearch(a, data, mid &#43; 1, High);</p>
<p>&nbsp;&nbsp; &nbsp;}</p>
<p>&nbsp;&nbsp; &nbsp;else </p>
<p>&nbsp;&nbsp; &nbsp;{</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return notFound;</p>
<p>&nbsp;&nbsp; &nbsp;}</p>
<p>}</p>
<p></p>
<pre><code>&lt;div&gt;
    作者：StruggleShu 发表于2016/5/9 22:06:15 [原文链接](http://blog.csdn.net/struggleshu/article/details/51356666)
&lt;/div&gt;
&lt;div&gt;
阅读：424 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/51356666#comments)
&lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/02/原-C语言中一类特殊的数组越界！！/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/02/原-C语言中一类特殊的数组越界！！/" itemprop="url">[原]C语言中一类特殊的数组越界！！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-02T16:16:55+08:00">
                2016-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="font-size:18px">首先看一段C语言程序（红色字体部分数组越界访问）和运行的结果（系统unbantu15.10，编辑器 vim）</span></p>
<p><span style="font-size:18px"></span></p>
<p></p>
<p><pre name="code" class="objc">&lt;span style=&quot;font-size:18px;&quot;&gt;# include &lt;stdio.h&gt;<br>int a[2] = {2, 3};<br>int b;</pre></p>
<p>void func()<br>{<br>    static int s = 8;<br>}</p>
<p>int main(void)<br>{<br>    b = 12;</p>
<pre><code>func();
&amp;lt;span style=&amp;quot;color:#FF0000;&amp;quot;&amp;gt;printf(&amp;quot;%d&amp;quot;, a[2]);//越界访问&amp;lt;/span&amp;gt;
return 0;
</code></pre><p>}&lt;/span&gt;<span style="font-size:18px"></span></p>
<p><img src="http://img.blog.csdn.net/20160502160835009?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><span style="font-size:18px">运行结果，程序并没有报错，也没崩溃，多次运行，还是一样！！！！</span></p>
<p><span style="font-size:18px">刚看见时，确实挺惊讶的，思考分析了半天，终于搞懂了</span></p>
<p><span style="font-size:18px">首先仔细观察，运行结果为8，和函数func中的静态局部变量s的&#20540;一样，多次修改s的&#20540;运行，也一样！！难道数组越界后访问了静态变量s的&#20540;？</span></p>
<p><span style="font-size:18px">基于思考，google了下，静态变量和全局变量的存储位置，总结如下</span></p>
<p><span style="font-size:18px">1.静态变量和全局变量都存储在内存的静态区。</span></p>
<p><span style="font-size:18px">2.静态区分为数据段（data segment, .data段）和BSS段（bss segment, .bss段）</span></p>
<p></p>
<p><span style="font-size:18px">&nbsp;&nbsp; 2.1-数据段：通常是用来存放程序中已初始化的全局变量的一块内存区域</span></p>
<p><span style="font-size:18px">&nbsp;&nbsp; 2.2-BBS段：通常是指用来存放程序中未初始化的全局变量的内存区域。</span></p>
<p><span style="font-size:18px">3</span><span style="font-size:18px">。</span><span style="font-size:18px">全局变量和静态变量的存储是放在一块的，初始化了的全局变量和静态变量在一块</span><span style="font-size:18px">区域</span></p>
<p><pre id="best-content-1873926733" class="best-text mb-10"><span style="font-size:18px">未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</span></pre><br><span style="font-size:18px"></span></p>
<p></p>
<p><span style="font-size:18px">结合以上，分析程序</span></p>
<p><span style="font-size:18px">全局变量数组a和静态局部变量s都已被初始化，都被存储在静态区的数据段这一块区域！！！</span></p>
<p><span style="font-size:18px">且通过程序可以更加推断出来，这两个数据不仅被放在一块区域，而且是连续存放的！！！！</span></p>
<p></p>
<pre><code>&lt;div&gt;
    作者：StruggleShu 发表于2016/5/2 16:16:55 [原文链接](http://blog.csdn.net/struggleshu/article/details/51296827)
&lt;/div&gt;
&lt;div&gt;
阅读：970 评论：5 [查看评论](http://blog.csdn.net/struggleshu/article/details/51296827#comments)
&lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/23/原-ubuntu下编写并运行第一个c语言程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu.Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="It's my blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/23/原-ubuntu下编写并运行第一个c语言程序/" itemprop="url">[原]ubuntu下编写并运行第一个c语言程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-23T22:38:10+08:00">
                2016-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="font-family:KaiTi_GB2312; font-size:18px">对于初入Ubantu系统的小伙伴来说，进入<a href="http://www.linuxidc.com/topicnews.aspx?tid=2" title="Ubuntu" target="_blank" rel="external">Ubuntu</a>最想做的事莫过于在终端（Terminal）里运行自己的第一个C/C&#43;&#43;程序&quot;hello.c/hello.cpp&quot;了。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">Ubuntu默认是不包含编辑器vim和编译器gcc。如果你是刚安装好的Ubuntu电脑，下面我们将来实现自己的第一个程序。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">1.准备工作</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">1.1 打开控制台：使用快捷键 Ctrl &#43; Alt &#43; T；</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">1.2 安装vim：输入 sudo apt-get install vim；</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">1.3 安装gcc：输入 sudo apt-get install g&#43;&#43;。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">2.编写，编译，运行</span></p>
<p></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px"></span></p>
<div>2.1：打开终端，随便进入一个文件夹用于存放你编写的程序</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>#cd /media/zhou/Material/linux-c</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>#vi Hello.c</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>接着你就会看到vi编辑器，按i开始输入（输入i后不需要回车），接着直接输入你的代码，</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>输完后按Esc，再输入&quot;:wq&quot;（引号内）保存退出，<br><br><img src="http://img.blog.csdn.net/20160423225544352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>好，现在你已经用vi编辑好了你程序。</div><br><div>2.2：用gcc编译你的程序</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>在终端输入</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>#gcc -o Hello Hello.c</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>编译完成后，在你的文件中出现一个hello运行文件。</div><br><div>2.3：运行编译好到Hello（注意大小写）文件，在终端输入</div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>#./Hello<br><br><img src="http://img.blog.csdn.net/20160423225805770?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></div><br><div>&nbsp;<wbr> &nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>到这一步你的程序成功运行。</div>

<pre><code>&lt;div&gt;
    作者：StruggleShu 发表于2016/4/23 22:38:10 [原文链接](http://blog.csdn.net/struggleshu/article/details/51228795)
&lt;/div&gt;
&lt;div&gt;
阅读：8582 评论：0 [查看评论](http://blog.csdn.net/struggleshu/article/details/51228795#comments)
&lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Shu.Zhou</p>
              <p class="site-description motion-element" itemprop="description">��������</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shu.Zhou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
